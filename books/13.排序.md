原地排序：特指空间复杂度是 O(1) 的排序算法
稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

#### 冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
原地排序
稳定
最好情况  O（n）  最坏情况 O（n2）  平均 O（n2）

#### 插入排序
我们只要遍历数组，找到数据应该插入的位置将其插入即可
插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
原地排序
稳定
最好情况  O（n）  最坏情况 O（n2）  平均 O（n2）

#### 选择排序
每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
原地排序
不稳定 （涉及到交换位置）
最好情况  O（n）  最坏情况 O（n2）  平均 O（n2）

#### 快速排序
快速排序是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，
它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，
后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序
原地排序
不稳定
最好情况 O(nlogn) 最坏 O(n2) 平均 O(nlogn)

#### 归并排序
分而治之(divide - conquer);每个递归过程涉及三个步骤
第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.
第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作
第三, 合并: 合并两个排好序的子序列,生成排序结果.
不原地
稳定
最好情况 O(nlogn) 最坏 O(nlogn) 平均 O(nlogn)

#### 堆排序
利用数组构建大顶堆（查最小）， 小顶堆（查最大）
升序：构建大顶堆，之后交换堆顶和堆尾元素，断开堆尾元素
降序类似

#### 动态规划