#### java是什么
java是一种面向对象的编程语言

#### 什么是面向对象
封装、继承和多态
封装：控制对成员的访问 第一个原因是防止程序员接触他们不该接触的东西——通常是内部数据类型的设计思想；第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响
继承：重新使用接口 java的类不支持多重继承  接口支持多重实现
多态：可以使用接口实现

#### 编译与解释
编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。

#### 字符型常量和字符串常量
形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符
含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
占内存大小: 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)

#### java基本类型所占字节大小
|  基本类型  |   大小  |   位  |
|   ----   |   ----  | ----  |
|  boolean  |    ——    |  —— |
|  void     |    ——    |  —— |
|  char     |   16bit  |  2  |
|  byte     |    8bit  |  1  |
|  short    |   16bit  |  2  |
|  int      |   32bit  |  4  |
|  long     |   64bit  |  8  |
|  float    |   32bit  |  4  |
|  double   |   64bit  |  8  |

#### 常见泛型通配符
？ 表示不确定的 java 类型
T (type) 表示具体的一个 java 类型
K V (key value) 分别代表 java 键值中的 Key Value
E (element) 代表 Element

#### ==、equals和hashcode()
== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

#### 反射机制
反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。
通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

#### try、catch和finally
以下 3 种特殊情况下，finally 块不会被执行：
在 try 或 finally 块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行
程序所在的线程死亡。
关闭 CPU。

#### 引用类型有哪些 有哪些区别
引用类型主要分为强软弱虚四种：
1、强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。
2、软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。
3、弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。
4、虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。

#### 静态代理和动态代理
- 静态代理主要有两大劣势
  代理类只代理一个委托类（其实可以代理多个，但不符合单一职责原则），也就意味着如果要代理多个委托类，就要写多个代理（别忘了静态代理在编译前必须确定）
  第一点还不是致命的，再考虑这样一种场景：如果每个委托类的每个方法都要被织入同样的逻辑，比如说我要计算前文提到的每个委托类每个方法的耗时，就要在方法开始前，开始后分别织入计算时间的代码，那就算用代理类，它的方法也有无数这种重复的计算时间的代码
- 动态代理 分为 JDK 提供的动态代理和 Spring AOP 用到的 CGLib 生成的代理
  如果要用 JDK 代理，委托类必须实现接口
  CGLib 利用 Enhancer 这个类来设置委托类与方法拦截器，这样委托类的所有非 final 方法就能被方法拦截器拦截，从而在拦截器里实现增强
  
#### 为什么需要静态内部类
1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。
2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。
这样静态内部类就可以理解了，因为这个类没有必要单独存放一个文件，它一般来说只被所在外部类使用。并且它可以直接被用 外部类名+内部类名 获得。
非静态内部类中不能有静态成员变量。一般情况下，如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态成员变量与静态成员方法的。也就是说，在非静态内部类中不可以声明静态成员。

#### >> 、 >>> 和 <<< 区别
<<  :     左移运算符，num << 1,相当于num乘以2
>>  :     右移运算符，num >> 1,相当于num除以2
>>> :     无符号右移，忽略符号位，空位都以0补齐