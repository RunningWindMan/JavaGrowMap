#### 为什么使用线程池

在连接数少的情况下，对于需要线程的地方我们只需要直接新建线程来处理就可以了，但是在并发量高的场景下，频繁的线程创建、销毁是非常消耗资源的，所以针对于这样的场景可以使用线程池，让一开始就创建好线程，在需要新连接进来需要线程时就从线程池中拿一条执行，完成后再将线程放回线程池，等到其他线程需要时再获取就可以了，这样可以有效提高系统整体的性能。

#### 线程池的好处？适应场景？

好处：
1、降低资源损耗　　
2、响应速度快　　
3、方便线程管理　　
4、提供定时执行、定期执行、并发数控制等功能。
适用场景：并发量大，IO操作多，需要频繁创建线程的场景。

#### 线程池执行机制
当新的线程请求进来时，会先判断核心线程数是否已满，如果未满则直接新建线程并执行，执行完将其放回线程池；
如果已满就再检查队列是否已满，如果没满就将当前线程请求加入阻塞队列，等待空闲线程分配；
如果已满就再检查线程池当前存在的线程数是否已达到规定的最大值，如果没有达到就创建线程执行；
如果达到就执行对应的拒绝策略。

#### 线程拒绝策略
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。           
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

#### 何时触发拒绝策略
通常情况下，我们认为只有1种，就是在：队列满了+核心线程与临时线程之后等于最大值时，又有任务加入就会触发。
但是还有一种情况，就是调用shutdown后，线程池会将正在执行的任务执行完毕后才真正退出，此时如果再加入了一个任务，也会触发拒绝策略。

#### 几种常见线程池
Executors.newSingletonThreadExecutor：可以看到这个线程池就是一个单线程的线程池，只能存储一个线程，但是它的阻塞队列是 LinkedBlockingQueue，所以意味着阻塞队列的容量可以看作是无限大的。
Executors.newFixedThreadPool(int)：这个线程池的最大线程数是传参值，核心线程数也是传参值，这意味着在工作线程执行完后回到线程池永远不会被回收，使用的阻塞队列也是 LinkedBlockingQueue。
Executors.newCachedThreadPool()：这里的核心线程数是0，也就是线程池在空闲时会回收所有的线程，但是最大线程数是 Integer的最大范围，所以可以看作可以同时包括无限大的线程，并且使用的阻塞队列是 SynchronousQueue，所以当线程请求进来时总会立即创建线程执行。
Executors.newScheduledThreadPool(int)：这个线程池的核心线程数是指定的参数，最大线程数同样是无限大，阻塞队列是 DelayedWorkQueue()，默认容量是16。
上面四种封装好的线程池都有缺陷，前两个因为阻塞队列是 LinkedBlockingQueue，所以在大量的线程请求进来时大部分会存储在阻塞队列中，最终撑爆堆空间，抛出OOM；而后两个因为允许的最大线程数是 Integer.MAX_VALUE，所以可以看作是无限大的，所以在大量的线程请求进来时也会因为创建过多的线程数而抛出OOM。所以这四种线程池需要慎用。