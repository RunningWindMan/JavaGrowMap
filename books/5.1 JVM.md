##### jvm运行时数据区

堆，栈，本地方法栈，方法区（元空间），程序计数器（PC寄存器）

栈中存放：局部变量表，操作数栈，动态链接，方法出口

##### 字节码执行引擎

gc

##### 字节码文件

cafe babe， javap指令

##### 优化

##### 对象划分

分配对象划分内存方法：指针碰撞，空闲列表 解决并发：CAS，TLAB

##### 指针压缩 栈上分配 逃逸

指针压缩：压缩字节码中对象头或指针中指针大小 为什么指针压缩：32位最大使用内存4G，为了减少64位平台下内存的消耗，启用指针压缩功能

逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中

标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就
不会因为没有一大块连续空间导致对象内存不够分配。

##### 对象动态年龄判断

当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)
，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了

##### 老年代空间分配担保

年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间 如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)
就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。
如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾， 如果回收完还是没有足够空间存放新的对象就会发生"OOM"
当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”
