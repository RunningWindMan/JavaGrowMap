#### 数据隔离级别
- 读未提交
- 读已提交 （可解决脏读）
- 可重复读 （可解决脏读，不可重复读）  Mysql的MVCC多版本控制机制
- 串行化 （可解决脏读，不可重复读，幻读）

#### 数据库索引类型
- 唯一索引 （允许空值）
- 主键索引 （不允许空值）
- 普通索引
- 联合索引 （最左原则）
- 全文索引

#### 数据库索引实现
B+Tree
R-Tree
Hash（不支持排序 范围查找）
FullText

#### mysql中锁类型
- 行锁
- 表锁
- 共享锁（其他事务可以读，但不能写）
- 排它锁（其他事务不能读，不能写）

#### MVCC
多版本并发控制，解决悲观锁

#### 事务实现
redolog undolog binlog

#### 回表 索引覆盖
普通索引查不到需要到主键索引再次查询；
利用索引覆盖可以避免回表

#### 聚簇索引 非聚簇索引
MyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。
这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，
辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。
由于索引树是独立的，通过辅助键检索无需访问主键的索引树。InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，
这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。

InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，
之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。
第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。