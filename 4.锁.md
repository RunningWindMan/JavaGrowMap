#### 重入锁
重入锁使得同一个线程可以对同一把锁，在不释放的前提下，反复加锁，而不会导致线程卡死。因此，如果我们使用的是重入锁，那么上述代码就 可以正常工作。你唯一需要保证的，就是unlock()的次数和lock()一样多。

#### java中可重入锁
实现重入锁的方法很简单，就是基于一个状态变量state。这个变量保存在AbstractQueuedSynchronizer对象中。当这个state==0时，表示锁是空闲的，大于零表示锁已经被占用， 它的数值表示当前线程重复占用这个锁的次数。

对于同一个线程，重入锁允许你反复获得通一把锁，但是，申请和释放锁的次数必须一致。
默认情况下，重入锁是非公平的，公平的重入锁性能差于非公平锁
重入锁的内部实现是基于CAS操作的。
重入锁的伴生对象Condition提供了await()和singal()的功能，可以用于线程间消息通信。

#### CAS缺点
<b>ABA问题</b>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。
Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。
<b>循环时间长开销大</b>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。
<b>只能保证一个共享变量的原子操作</b>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。